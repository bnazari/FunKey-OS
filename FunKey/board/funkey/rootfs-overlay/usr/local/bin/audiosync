#!/usr/bin/python
# -*- coding: utf-8 -*-
import os
import time
import sys
import signal
import argparse
import alsaaudio
import pyudev
import subprocess
 # create argument parser to get start/stop argument
parser = argparse.ArgumentParser(description='Start and stop process using PID')
parser.add_argument('command', choices=['start', 'stop'], help='Start or stop process')
args = parser.parse_args()
 # define process name
process_name = 'audiosync'
 # define pid file
pid_file = '/var/run/audiosync.pid'


# Define a function to kill a process by name or PID
num_cards = 0;

def killapp(process_id):
    try:
        # Try to convert the process ID to an integer
        pid = int(process_id)
    except ValueError:
        # If the input is not an integer, assume it is a process name and use ps command to get PID
        try:
            ps_output = subprocess.check_output(['ps', '-A'])
            matching_lines = [line for line in ps_output.split('\n') if process_id in line]
            pid = int(matching_lines[0].split()[0])
            # Send signal 1 to the process
            #subprocess.call(['kill', '-1', str(pid)])
            os.kill(int(pid), signal.SIGUSR1)
            #os.kill(int(pid), signal.SIGTERM)            
	    try:                                            
        	print("wait process {} exit".format(pid))
        	os.waitpid(pid, 0)                                         
    	    except OSError:                                                        
        	pass

            # Print a message indicating that the process has been killed
            print('Process ID {} has been killed.'.format(pid))
        except (ValueError, IndexError):
            # If the process name is not found or cannot be converted to an integer, raise an exception
            print('Process name or PID not found: {}'.format(process_id))

 # Define the callback function to handle sound card events
def handle_sound_card_event(action, device):
    global num_cards
    _num_cards = 0
    print("event",device,action)
    cards = alsaaudio.cards()                                         
    _num_cards = len(cards)
    print('The following sound cards are currently available:', cards)
    if(num_cards != _num_cards):
        num_cards = _num_cards
        killapp('gmu.bin')
    if device is not None and device.get('SUBSYSTEM') == 'sound' and 'card' in device.get('DEVNAME', ''):
        card_index = int(device.get('DEVNAME').split('card')[1])
        print('Sound card {} has been {}.'.format(card_index, action))
 # function to start process
def start_process():
    pid = os.getpid()
    print 'Starting %s with PID %d' % (process_name, pid)
    # start your process here
    # save pid to file
    with open(pid_file, 'w') as f:
        f.write(str(pid))
    # Create a context object for monitoring udev events                 
    context = pyudev.Context()                                               
     # Monitor udev events of the sound subsystem                            
    monitor = pyudev.Monitor.from_netlink(context)                 
    monitor.filter_by('sound')                                                                             
     # Get the current status of sound cards and print them                                                
    cards = alsaaudio.cards()                                                                          
    print('The following sound cards are currently available:', cards)                                 
     # Add the callback function to the monitor                                                              
    observer = pyudev.MonitorObserver(monitor, handle_sound_card_event)                        
    observer.start()                                                                           
     # Wait for sound card events indefinitely                                                 
    # while True:                                                              
    #     pass                  
    try:
        while True:
            time.sleep(0.2)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

 # function to stop process
def stop_process():
    # check if pid file exists
    if not os.path.isfile(pid_file):
        print('PID file does not exist')
        return
    # read pid from pid file
    with open(pid_file, 'r') as f:
        pid = int(f.read().strip())
    print 'Stopping %s with PID %d' % (process_name, pid)
    # kill the process using the pid
    try:
        os.kill(pid, signal.SIGTERM)
    except ProcessLookupError:
        print 'Process with PID %d not found' % pid
    # remove pid file
    os.remove(pid_file)
def daemonize():
    # 创建子进程
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)  # 父进程退出
    except OSError as e:
        sys.stderr.write("fork #1 failed: %d (%s)\n" % (e.errno, e.strerror))
        sys.exit(1)
    
    # 切换工作目录
    os.chdir("/")
    # 重设文件权限掩码
    os.umask(0)
    # 创建新的会话
    os.setsid()
    
    # 第二次fork，避免获得控制终端
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)  # 第一子进程退出
    except OSError as e:
        sys.stderr.write("fork #2 failed: %d (%s)\n" % (e.errno, e.strerror))
        sys.exit(1)
        
    # 重定向标准文件描述符
    sys.stdout.flush()
    sys.stderr.flush()
    si = open(os.devnull, 'r')
    so = open(os.devnull, 'a+')
    se = open(os.devnull, 'a+')
    os.dup2(si.fileno(), sys.stdin.fileno())
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(se.fileno(), sys.stderr.fileno())
 # start or stop process based on command line argument
if args.command == 'start':
    if __name__ == '__main__':
        daemonize()
        start_process()
elif args.command == 'stop':
    stop_process()
